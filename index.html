<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Work Schedule App</title>
    <style>
        :root {
            --bg-color: #f5f6f5;
            --container-bg: #ffffff;
            --text-color: #2d2d2d;
            --li-bg: #e8ecef;
            --section-border: #d1d5db;
            --active-bg: #90ee90;
            --completed-bg: #f1f3f5;
            --drag-over-bg: #d1d5db;
            --subtask-bg: #f9fafb;
        }
        .dark-mode {
            --bg-color: #1f2937;
            --container-bg: #374151;
            --text-color: #e5e7eb;
            --li-bg: #4b5563;
            --section-border: #6b7280;
            --active-bg: #68d391;
            --completed-bg: #2d3748;
            --drag-over-bg: #6b7280;
            --subtask-bg: #2d3748;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background: var(--container-bg);
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 700px;
            width: 100%;
        }
        h1 {
            text-align: center;
            font-size: 2em;
            margin-bottom: 20px;
        }
        .section {
            margin-bottom: 24px;
        }
        .section h2 {
            border-bottom: 2px solid var(--section-border);
            padding-bottom: 8px;
            font-size: 1.5em;
        }
        ul {
            list-style: none;
            padding: 0;
            min-height: 20px;
        }
        ul.drag-over:not(.subtask-list) {
            background: var(--drag-over-bg);
            border: 2px dashed var(--section-border);
            border-radius: 8px;
        }
        ul.subtask-list.drag-over {
            background: var(--drag-over-bg);
            border: 1px dashed var(--section-border);
            border-radius: 6px;
        }
        li.task, li.subtask {
            padding: 12px;
            margin: 8px 0;
            background: var(--li-bg);
            border-radius: 8px;
            transition: background 0.3s, transform 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            cursor: move;
        }
        li.subtask {
            margin-left: 20px;
            background: var(--subtask-bg);
        }
        li.task.dragging, li.subtask.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }
        li.task:hover, li.subtask:hover {
            transform: scale(1.02);
        }
        li.task.active {
            background: var(--active-bg);
            font-weight: 600;
        }
        li.task.completed, li.subtask.completed {
            text-decoration: line-through;
            opacity: 0.7;
            background: var(--completed-bg);
        }
        li.task:hover .edit-btn, li.task:hover .delete-btn, li.task:hover .complete-btn, li.task:hover .back-btn, li.task:hover .add-subtask-btn,
        li.subtask:hover .edit-btn, li.subtask:hover .delete-btn, li.subtask:hover .complete-btn, li.subtask:hover .back-btn {
            display: inline-block;
        }
        .subtask-list {
            display: none;
            margin-left: 20px;
        }
        .subtask-list.expanded {
            display: block;
        }
        .toggle-subtasks {
            cursor: pointer;
            margin-right: 8px;
            font-size: 0.9em;
        }
        .section-label {
            font-size: 0.8em;
            color: #6b7280;
            margin-left: 8px;
        }
        .completed-timestamp {
            font-size: 0.8em;
            color: #6b7280;
            margin-left: 8px;
        }
        #current-task {
            text-align: center;
            font-size: 1.3em;
            margin-bottom: 12px;
            color: #2563eb;
        }
        #timer {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 12px;
        }
        button, input[type="submit"] {
            margin: 12px auto;
            padding: 10px 24px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }
        button:hover, input[type="submit"]:hover {
            background: #1e40af;
            transform: scale(1.05);
        }
        form {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 24px;
        }
        input, select {
            padding: 10px;
            border: 1px solid var(--section-border);
            border-radius: 6px;
            font-size: 1em;
        }
        .delete-btn, .edit-btn, .complete-btn, .back-btn, .add-subtask-btn {
            padding: 6px 12px;
            font-size: 0.9em;
            margin-left: 8px;
        }
        .delete-btn {
            background: #ef4444;
        }
        .delete-btn:hover {
            background: #b91c1c;
        }
        .edit-btn {
            background: #2ecc71;
            display: none;
        }
        .edit-btn:hover {
            background: #27ae60;
        }
        .complete-btn {
            background: #f59e0b;
            display: none;
        }
        .complete-btn:hover {
            background: #d97706;
        }
        .back-btn {
            background: #8b5cf6;
            display: none;
        }
        .back-btn:hover {
            background: #7c3aed;
        }
        .add-subtask-btn {
            background: #3b82f6;
            display: none;
        }
        .add-subtask-btn:hover {
            background: #2563eb;
        }
        .edit-form, .subtask-form {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            background: var(--li-bg);
            border-radius: 8px;
            margin-top: 12px;
        }
        .subtask-form {
            margin-left: 20px;
        }
        .notification-status-container {
            display: flex;
            justify-content: center;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }
        .notification-status {
            text-align: center;
            font-size: 0.9em;
            margin-top: 10px;
        }
        @media (max-width: 600px) {
            .container {
                padding: 16px;
            }
            h1 {
                font-size: 1.6em;
            }
            li.task, li.subtask {
                font-size: 0.9em;
                padding: 10px;
            }
            .section-label, .completed-timestamp {
                font-size: 0.7em;
            }
            #current-task, #timer {
                font-size: 1.1em;
            }
            button, input, select {
                padding: 8px;
                font-size: 0.9em;
            }
            form, .edit-form, .subtask-form {
                flex-direction: column;
            }
        }

        /* Raihan Customize */
        form#add-task-form input[type="submit"] {
            margin: 10px 0;
        }
        #theme-toggle {
            display: none;
        }
        button#reset-schedule {
            display: flex;
            margin-top: 100px;
        }
        li.task.active {padding: 12px;}

        li.task, li.subtask {
            padding: 0 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Focus Work Schedule</h1>
        <div id="current-task" aria-live="polite">Current Task: None</div>
        <div id="timer" aria-live="polite">Time Left: --</div>
        <button id="theme-toggle" aria-label="Toggle dark mode">Toggle Dark Mode</button>
        <div class="section">
            <h2>Add Task</h2>
            <form id="add-task-form">
                <input type="time" id="start-time" required aria-label="Start time">
                <input type="time" id="end-time" required aria-label="End time">
                <input type="text" id="task-name" placeholder="Task name" required aria-label="Task name">
                <select id="section" aria-label="Schedule section">
                    <option value="morning" title="Morning tasks">Morning</option>
                    <option value="noon" title="Noon tasks">Noon</option>
                    <option value="evening" title="Evening tasks">Evening</option>
                    <option value="important_urgent" title="Crises">Important, urgent</option>
                    <option value="important_not_urgent" title="Goals & Planning">Important but not urgent</option>
                    <option value="not_important_urgent" title="Interruptions">Not Important, urgent</option>
                    <option value="neither_urgent_nor_important" title="Distractions">Neither urgent nor important</option>
                </select>
                <input type="submit" value="Add Task">
            </form>
        </div>
        <div class="section morning">
            <h2>Morning</h2>
            <ul id="morning-tasks" data-section="morning"></ul>
        </div>
        <div class="section noon">
            <h2>Noon</h2>
            <ul id="noon-tasks" data-section="noon"></ul>
        </div>
        <div class="section evening">
            <h2>Evening</h2>
            <ul id="evening-tasks" data-section="evening"></ul>
        </div>
        <div class="section important_urgent">
            <h2>Crises</h2>
            <ul id="important-urgent-tasks" data-section="important_urgent"></ul>
        </div>
        <div class="section important_not_urgent">
            <h2>Goals & Planning</h2>
            <ul id="important-not-urgent-tasks" data-section="important_not_urgent"></ul>
        </div>
        <div class="section not_important_urgent">
            <h2>Interruptions</h2>
            <ul id="not-important-urgent-tasks" data-section="not_important_urgent"></ul>
        </div>
        <div class="section neither_urgent_nor_important">
            <h2>Distractions</h2>
            <ul id="neither-urgent-nor-important-tasks" data-section="neither_urgent_nor_important"></ul>
        </div>
        <div class="section completed">
            <h2>Completed Tasks</h2>
            <ul id="completed-tasks" data-section="completed"></ul>
            <button id="clear-completed" aria-label="Clear all completed tasks" style="display: none;">Clear Completed Tasks</button>
            <button id="reset-schedule" aria-label="Reset schedule to default">Reset Schedule</button>
        </div>
        <div class="notification-status-container">
            <button id="toggle-notifications" aria-label="Toggle notifications">Enable Notifications</button>
            <div id="notification-status" class="notification-status" aria-live="polite">Notifications: Disabled</div>
        </div>
    </div>
    <audio id="alert-sound" src="alert.mp3"></audio>
    <script>
        // Default schedule with tasks in new categories, including subtasks
        const defaultSchedule = [
            { start: "06:00", end: "07:00", task: "Market place", section: "morning", completed: false, subtasks: [] },
            { start: "07:00", end: "08:00", task: "Agency", section: "morning", completed: false, subtasks: [] },
            { start: "08:00", end: "09:00", task: "Loom video", section: "morning", completed: false, subtasks: [] },
            { start: "09:00", end: "10:00", task: "Shopify", section: "morning", completed: false, subtasks: [] },
            { start: "11:00", end: "12:00", task: "Clients work if not find client", section: "noon", completed: false, subtasks: [] },
            { start: "12:00", end: "13:00", task: "Clients work if not find client", section: "noon", completed: false, subtasks: [] },
            { start: "13:00", end: "14:00", task: "Clients work if not find client", section: "noon", completed: false, subtasks: [] },
            { start: "14:00", end: "15:00", task: "ReCareUP work", section: "noon", completed: false, subtasks: [] },
            { start: "19:00", end: "20:00", task: "ReCareUP work", section: "evening", completed: false, subtasks: [] },
            { start: "10:00", end: "10:30", task: "Urgent client call", section: "important_urgent", completed: false, subtasks: [] },
            { start: "15:00", end: "16:00", task: "Long-term project planning", section: "important_not_urgent", completed: false, subtasks: [] },
            { start: "16:00", end: "16:30", task: "Respond to emails", section: "not_important_urgent", completed: false, subtasks: [] },
            { start: "17:00", end: "17:30", task: "Check social media", section: "neither_urgent_nor_important", completed: false, subtasks: [] }
        ];

        // Load tasks from localStorage or use default schedule
        let schedule = JSON.parse(localStorage.getItem('schedule')) || defaultSchedule;

        // DOM elements
        const currentTaskEl = document.getElementById('current-task');
        const timerEl = document.getElementById('timer');
        const morningTasksEl = document.getElementById('morning-tasks');
        const noonTasksEl = document.getElementById('noon-tasks');
        const eveningTasksEl = document.getElementById('evening-tasks');
        const importantUrgentTasksEl = document.getElementById('important-urgent-tasks');
        const importantNotUrgentTasksEl = document.getElementById('important-not-urgent-tasks');
        const notImportantUrgentTasksEl = document.getElementById('not-important-urgent-tasks');
        const neitherUrgentNorImportantTasksEl = document.getElementById('neither-urgent-nor-important-tasks');
        const completedTasksEl = document.getElementById('completed-tasks');
        const addTaskForm = document.getElementById('add-task-form');
        const themeToggle = document.getElementById('theme-toggle');
        const toggleNotifications = document.getElementById('toggle-notifications');
        const notificationStatus = document.getElementById('notification-status');
        const clearCompleted = document.getElementById('clear-completed');
        const resetSchedule = document.getElementById('reset-schedule');
        const alertSound = document.getElementById('alert-sound');

        // Notification state
        let notificationsEnabled = localStorage.getItem('notificationsEnabled') === 'true';
        updateNotificationStatus();

        // Dark mode toggle
        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
            renderTasks();
        });

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
        }

        // Notification toggle
        function updateNotificationStatus() {
            if (notificationsEnabled && Notification.permission === 'granted') {
                notificationStatus.textContent = 'Notifications: Enabled';
                toggleNotifications.textContent = 'Disable Notifications';
            } else {
                notificationStatus.textContent = 'Notifications: Disabled';
                toggleNotifications.textContent = 'Enable Notifications';
            }
        }

        toggleNotifications.addEventListener('click', () => {
            if (!notificationsEnabled) {
                Notification.requestPermission().then(permission => {
                    notificationsEnabled = permission === 'granted';
                    localStorage.setItem('notificationsEnabled', notificationsEnabled);
                    updateNotificationStatus();
                });
            } else {
                notificationsEnabled = false;
                localStorage.setItem('notificationsEnabled', notificationsEnabled);
                updateNotificationStatus();
            }
        });

        // Reset schedule
        resetSchedule.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the schedule to default? This will clear all tasks.')) {
                schedule = [...defaultSchedule];
                localStorage.setItem('schedule', JSON.stringify(schedule));
                renderTasks();
            }
        });

        // Format time to 12-hour format
        function formatTime(time) {
            const [hours, minutes] = time.split(':').map(Number);
            const period = hours >= 12 ? 'PM' : 'AM';
            const formattedHours = hours % 12 || 12;
            return `${formattedHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}${period}`;
        }

        // Format timestamp to readable date
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return `Completed: ${date.toLocaleString()}`;
        }

        // Render tasks
        function renderTasks() {
            morningTasksEl.innerHTML = '';
            noonTasksEl.innerHTML = '';
            eveningTasksEl.innerHTML = '';
            importantUrgentTasksEl.innerHTML = '';
            importantNotUrgentTasksEl.innerHTML = '';
            notImportantUrgentTasksEl.innerHTML = '';
            neitherUrgentNorImportantTasksEl.innerHTML = '';
            completedTasksEl.innerHTML = '';

            // Create a map of tasks with their original indices
            const taskIndices = new Map();
            schedule.forEach((task, index) => taskIndices.set(task, index));

            // Sort active and completed tasks
            const activeTasks = schedule.filter(task => !task.completed);
            const completedTasks = schedule.filter(task => task.completed).sort((a, b) => (b.completedAt || 0) - (a.completedAt || 0));

            // Section name mapping for display
            const sectionNames = {
                morning: 'Morning',
                noon: 'Noon',
                evening: 'Evening',
                important_urgent: 'Crises',
                important_not_urgent: 'Goals & Planning',
                not_important_urgent: 'Interruptions',
                neither_urgent_nor_important: 'Distractions',
                completed: 'Completed'
            };

            // Render active tasks
            activeTasks.forEach((task) => {
                const index = taskIndices.get(task);
                const li = document.createElement('li');
                li.classList.add('task');
                li.draggable = true;
                li.dataset.start = task.start;
                li.dataset.end = task.end;
                li.dataset.task = task.task;
                li.dataset.section = task.section;
                li.dataset.index = index;
                li.setAttribute('aria-grabbed', 'false');
                li.setAttribute('role', 'listitem');
                li.innerHTML = `
                    <span class="toggle-subtasks" aria-label="Toggle subtasks for ${task.task}">${task.subtasks && task.subtasks.length > 0 ? '▼' : '◄'}</span>
                    ${formatTime(task.start)} - ${formatTime(task.end)} - ${task.task}
                   <!-- <span class="section-label">[${sectionNames[task.section]}]</span> -->
                    <div>
                        <button class="complete-btn" aria-label="Complete task ${task.task}">Complete</button>
                        <button class="edit-btn" aria-label="Edit task ${task.task}">Edit</button>
                        <button class="delete-btn" aria-label="Delete task ${task.task}">Delete</button>
                        <button class="add-subtask-btn" aria-label="Add subtask to ${task.task}">Add Subtask</button>
                    </div>
                `;
                const editForm = document.createElement('form');
                editForm.classList.add('edit-form');
                editForm.innerHTML = `
                    <input type="time" name="edit-start" value="${task.start}" required aria-label="Edit start time">
                    <input type="time" name="edit-end" value="${task.end}" required aria-label="Edit end time">
                    <input type="text" name="edit-task" value="${task.task}" required aria-label="Edit task name">
                    <select name="edit-section" aria-label="Edit schedule section">
                        <option value="morning" title="Morning tasks" ${task.section === 'morning' ? 'selected' : ''}>Morning</option>
                        <option value="noon" title="Noon tasks" ${task.section === 'noon' ? 'selected' : ''}>Noon</option>
                        <option value="evening" title="Evening tasks" ${task.section === 'evening' ? 'selected' : ''}>Evening</option>
                        <option value="important_urgent" title="Crises" ${task.section === 'important_urgent' ? 'selected' : ''}>Important, urgent</option>
                        <option value="important_not_urgent" title="Goals & Planning" ${task.section === 'important_not_urgent' ? 'selected' : ''}>Important but not urgent</option>
                        <option value="not_important_urgent" title="Interruptions" ${task.section === 'not_important_urgent' ? 'selected' : ''}>Not Important, urgent</option>
                        <option value="neither_urgent_nor_important" title="Distractions" ${task.section === 'neither_urgent_nor_important' ? 'selected' : ''}>Neither urgent nor important</option>
                    </select>
                    <input type="submit" value="Save">
                    <button type="button" class="cancel-edit" aria-label="Cancel edit">Cancel</button>
                `;
                const subtaskForm = document.createElement('form');
                subtaskForm.classList.add('subtask-form');
                subtaskForm.innerHTML = `
                    <input type="text" name="subtask-description" placeholder="Subtask name" required aria-label="Subtask name">
                    <input type="submit" value="Add Subtask">
                    <button type="button" class="cancel-subtask" aria-label="Cancel adding subtask">Cancel</button>
                `;
                const subtaskList = document.createElement('ul');
                subtaskList.classList.add('subtask-list');
                subtaskList.dataset.parentIndex = index;
                if (task.subtasks && task.subtasks.length > 0) {
                    subtaskList.classList.add('expanded');
                }

                // Render subtasks
                (task.subtasks || []).forEach((subtask, subtaskIndex) => {
                    const subtaskLi = document.createElement('li');
                    subtaskLi.classList.add('subtask');
                    if (subtask.completed) subtaskLi.classList.add('completed');
                    subtaskLi.draggable = true;
                    subtaskLi.dataset.task = subtask.task;
                    subtaskLi.dataset.parentIndex = index;
                    subtaskLi.dataset.subtaskIndex = subtaskIndex;
                    subtaskLi.setAttribute('aria-grabbed', 'false');
                    subtaskLi.setAttribute('role', 'listitem');
                    subtaskLi.innerHTML = `
                        ${subtask.task}
                        <div>
                            ${subtask.completed
                                ? `<button class="back-btn" aria-label="Move subtask ${subtask.task} back to active">Back</button>`
                                : `<button class="complete-btn" aria-label="Complete subtask ${subtask.task}">Complete</button>`}
                            <button class="edit-btn" aria-label="Edit subtask ${subtask.task}">Edit</button>
                            <button class="delete-btn" aria-label="Delete subtask ${subtask.task}">Delete</button>
                        </div>
                    `;
                    const subtaskEditForm = document.createElement('form');
                    subtaskEditForm.classList.add('subtask-form');
                    subtaskEditForm.style.display = 'none';
                    subtaskEditForm.innerHTML = `
                        <input type="text" name="edit-subtask-task" value="${subtask.task}" required aria-label="Edit subtask name">
                        <input type="submit" value="Save">
                        <button type="button" class="cancel-edit-subtask" aria-label="Cancel editing subtask">Cancel</button>
                    `;
                    subtaskList.appendChild(subtaskLi);
                    subtaskList.appendChild(subtaskEditForm);

                    // Drag start for subtask
                    subtaskLi.addEventListener('dragstart', (e) => {
                        subtaskLi.classList.add('dragging');
                        subtaskLi.setAttribute('aria-grabbed', 'true');
                        e.dataTransfer.setData('text/plain', `${index}:${subtaskIndex}`);
                    });

                    // Drag end for subtask
                    subtaskLi.addEventListener('dragend', () => {
                        subtaskLi.classList.remove('dragging');
                        subtaskLi.setAttribute('aria-grabbed', 'false');
                        document.querySelectorAll('ul').forEach(ul => ul.classList.remove('drag-over'));
                    });

                    // Complete or move back subtask
                    if (subtask.completed) {
                        subtaskLi.querySelector('.back-btn').addEventListener('click', () => {
                            schedule[index].subtasks[subtaskIndex].completed = false;
                            localStorage.setItem('schedule', JSON.stringify(schedule));
                            renderTasks();
                        });
                    } else {
                        subtaskLi.querySelector('.complete-btn').addEventListener('click', () => {
                            schedule[index].subtasks[subtaskIndex].completed = true;
                            localStorage.setItem('schedule', JSON.stringify(schedule));
                            renderTasks();
                        });
                    }

                    // Edit subtask
                    subtaskLi.querySelector('.edit-btn').addEventListener('click', () => {
                        subtaskEditForm.style.display = 'flex';
                        subtaskLi.style.display = 'none';
                    });

                    // Save edited subtask
                    subtaskEditForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        const newTask = subtaskEditForm.querySelector('[name="edit-subtask-task"]').value;
                        schedule[index].subtasks[subtaskIndex] = {
                            task: newTask,
                            completed: schedule[index].subtasks[subtaskIndex].completed
                        };
                        localStorage.setItem('schedule', JSON.stringify(schedule));
                        renderTasks();
                    });

                    // Cancel edit subtask
                    subtaskEditForm.querySelector('.cancel-edit-subtask').addEventListener('click', () => {
                        subtaskEditForm.style.display = 'none';
                        subtaskLi.style.display = 'flex';
                    });

                    // Delete subtask
                    subtaskLi.querySelector('.delete-btn').addEventListener('click', () => {
                        schedule[index].subtasks.splice(subtaskIndex, 1);
                        localStorage.setItem('schedule', JSON.stringify(schedule));
                        renderTasks();
                    });
                });

                const targetList = {
                    morning: morningTasksEl,
                    noon: noonTasksEl,
                    evening: eveningTasksEl,
                    important_urgent: importantUrgentTasksEl,
                    important_not_urgent: importantNotUrgentTasksEl,
                    not_important_urgent: notImportantUrgentTasksEl,
                    neither_urgent_nor_important: neitherUrgentNorImportantTasksEl
                }[task.section];

                targetList.appendChild(li);
                targetList.appendChild(editForm);
                targetList.appendChild(subtaskForm);
                targetList.appendChild(subtaskList);

                // Toggle subtasks
                li.querySelector('.toggle-subtasks').addEventListener('click', () => {
                    const isExpanded = subtaskList.classList.toggle('expanded');
                    li.querySelector('.toggle-subtasks').textContent = isExpanded ? '▼' : '◄';
                    li.querySelector('.toggle-subtasks').setAttribute('aria-expanded', isExpanded);
                });

                // Add subtask
                li.querySelector('.add-subtask-btn').addEventListener('click', () => {
                    subtaskForm.style.display = 'flex';
                    li.style.display = 'none';
                });

                // Save new subtask
                subtaskForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const description = subtaskForm.querySelector('[name="subtask-description"]').value;
                    if (!schedule[index].subtasks) schedule[index].subtasks = [];
                    schedule[index].subtasks.push({ task: description, completed: false });
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Cancel add subtask
                subtaskForm.querySelector('.cancel-subtask').addEventListener('click', () => {
                    subtaskForm.style.display = 'none';
                    li.style.display = 'flex';
                });

                // Drag start for task
                li.addEventListener('dragstart', (e) => {
                    li.classList.add('dragging');
                    li.setAttribute('aria-grabbed', 'true');
                    e.dataTransfer.setData('text/plain', `${index}:`);
                });

                // Drag end for task
                li.addEventListener('dragend', () => {
                    li.classList.remove('dragging');
                    li.setAttribute('aria-grabbed', 'false');
                    document.querySelectorAll('ul').forEach(ul => ul.classList.remove('drag-over'));
                });

                // Complete task
                li.querySelector('.complete-btn').addEventListener('click', () => {
                    schedule[index].completed = true;
                    schedule[index].completedAt = Date.now();
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Delete task
                li.querySelector('.delete-btn').addEventListener('click', () => {
                    schedule.splice(index, 1);
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Edit task
                li.querySelector('.edit-btn').addEventListener('click', () => {
                    editForm.style.display = 'flex';
                    li.style.display = 'none';
                });

                // Save edited task
                editForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const newStart = editForm.querySelector('[name="edit-start"]').value;
                    const newEnd = editForm.querySelector('[name="edit-end"]').value;
                    const newTask = editForm.querySelector('[name="edit-task"]').value;
                    const newSection = editForm.querySelector('[name="edit-section"]').value;

                    if (newStart >= newEnd) {
                        alert('End time must be after start time.');
                        return;
                    }

                    schedule[index] = { start: newStart, end: newEnd, task: newTask, section: newSection, completed: schedule[index].completed, completedAt: schedule[index].completedAt, subtasks: schedule[index].subtasks };
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Cancel edit
                editForm.querySelector('.cancel-edit').addEventListener('click', () => {
                    editForm.style.display = 'none';
                    li.style.display = 'flex';
                });
            });

            // Render completed tasks
            completedTasks.forEach((task) => {
                const index = taskIndices.get(task);
                const li = document.createElement('li');
                li.classList.add('task', 'completed');
                li.draggable = true;
                li.dataset.start = task.start;
                li.dataset.end = task.end;
                li.dataset.task = task.task;
                li.dataset.section = task.section;
                li.dataset.index = index;
                li.setAttribute('aria-grabbed', 'false');
                li.setAttribute('role', 'listitem');
                li.innerHTML = `
                    <span class="toggle-subtasks" aria-label="Toggle subtasks for ${task.task}">${task.subtasks && task.subtasks.length > 0 ? '▼' : '◄'}</span>
                    ${formatTime(task.start)} - ${formatTime(task.end)} - ${task.task}
                    <!-- <span class="section-label">[${sectionNames[task.section]}]</span>  -->
                    <span class="completed-timestamp">${formatTimestamp(task.completedAt)}</span>
                    <div>
                        <button class="back-btn" aria-label="Move task ${task.task} back to active">Back</button>
                        <button class="edit-btn" aria-label="Edit task ${task.task}">Edit</button>
                        <button class="delete-btn" aria-label="Delete task ${task.task}">Delete</button>
                        <button class="add-subtask-btn" aria-label="Add subtask to ${task.task}">Add Subtask</button>
                    </div>
                `;
                const editForm = document.createElement('form');
                editForm.classList.add('edit-form');
                editForm.innerHTML = `
                    <input type="time" name="edit-start" value="${task.start}" required aria-label="Edit start time">
                    <input type="time" name="edit-end" value="${task.end}" required aria-label="Edit end time">
                    <input type="text" name="edit-task" value="${task.task}" required aria-label="Edit task name">
                    <select name="edit-section" aria-label="Edit schedule section">
                        <option value="morning" title="Morning tasks" ${task.section === 'morning' ? 'selected' : ''}>Morning</option>
                        <option value="noon" title="Noon tasks" ${task.section === 'noon' ? 'selected' : ''}>Noon</option>
                        <option value="evening" title="Evening tasks" ${task.section === 'evening' ? 'selected' : ''}>Evening</option>
                        <option value="important_urgent" title="Crises" ${task.section === 'important_urgent' ? 'selected' : ''}>Important, urgent</option>
                        <option value="important_not_urgent" title="Goals & Planning" ${task.section === 'important_not_urgent' ? 'selected' : ''}>Important but not urgent</option>
                        <option value="not_important_urgent" title="Interruptions" ${task.section === 'not_important_urgent' ? 'selected' : ''}>Not Important, urgent</option>
                        <option value="neither_urgent_nor_important" title="Distractions" ${task.section === 'neither_urgent_nor_important' ? 'selected' : ''}>Neither urgent nor important</option>
                    </select>
                    <input type="submit" value="Save">
                    <button type="button" class="cancel-edit" aria-label="Cancel edit">Cancel</button>
                `;
                const subtaskForm = document.createElement('form');
                subtaskForm.classList.add('subtask-form');
                subtaskForm.innerHTML = `
                    <input type="text" name="subtask-description" placeholder="Subtask name" required aria-label="Subtask name">
                    <input type="submit" value="Add Subtask">
                    <button type="button" class="cancel-subtask" aria-label="Cancel adding subtask">Cancel</button>
                `;
                const subtaskList = document.createElement('ul');
                subtaskList.classList.add('subtask-list');
                subtaskList.dataset.parentIndex = index;
                if (task.subtasks && task.subtasks.length > 0) {
                    subtaskList.classList.add('expanded');
                }

                // Render subtasks
                (task.subtasks || []).forEach((subtask, subtaskIndex) => {
                    const subtaskLi = document.createElement('li');
                    subtaskLi.classList.add('subtask');
                    if (subtask.completed) subtaskLi.classList.add('completed');
                    subtaskLi.draggable = true;
                    subtaskLi.dataset.task = subtask.task;
                    subtaskLi.dataset.parentIndex = index;
                    subtaskLi.dataset.subtaskIndex = subtaskIndex;
                    subtaskLi.setAttribute('aria-grabbed', 'false');
                    subtaskLi.setAttribute('role', 'listitem');
                    subtaskLi.innerHTML = `
                        ${subtask.task}
                        <div>
                            ${subtask.completed
                                ? `<button class="back-btn" aria-label="Move subtask ${subtask.task} back to active">Back</button>`
                                : `<button class="complete-btn" aria-label="Complete subtask ${subtask.task}">Complete</button>`}
                            <button class="edit-btn" aria-label="Edit subtask ${subtask.task}">Edit</button>
                            <button class="delete-btn" aria-label="Delete subtask ${subtask.task}">Delete</button>
                        </div>
                    `;
                    const subtaskEditForm = document.createElement('form');
                    subtaskEditForm.classList.add('subtask-form');
                    subtaskEditForm.style.display = 'none';
                    subtaskEditForm.innerHTML = `
                        <input type="text" name="edit-subtask-task" value="${subtask.task}" required aria-label="Edit subtask name">
                        <input type="submit" value="Save">
                        <button type="button" class="cancel-edit-subtask" aria-label="Cancel editing subtask">Cancel</button>
                    `;
                    subtaskList.appendChild(subtaskLi);
                    subtaskList.appendChild(subtaskEditForm);

                    // Drag start for subtask
                    subtaskLi.addEventListener('dragstart', (e) => {
                        subtaskLi.classList.add('dragging');
                        subtaskLi.setAttribute('aria-grabbed', 'true');
                        e.dataTransfer.setData('text/plain', `${index}:${subtaskIndex}`);
                    });

                    // Drag end for subtask
                    subtaskLi.addEventListener('dragend', () => {
                        subtaskLi.classList.remove('dragging');
                        subtaskLi.setAttribute('aria-grabbed', 'false');
                        document.querySelectorAll('ul').forEach(ul => ul.classList.remove('drag-over'));
                    });

                    // Complete or move back subtask
                    if (subtask.completed) {
                        subtaskLi.querySelector('.back-btn').addEventListener('click', () => {
                            schedule[index].subtasks[subtaskIndex].completed = false;
                            localStorage.setItem('schedule', JSON.stringify(schedule));
                            renderTasks();
                        });
                    } else {
                        subtaskLi.querySelector('.complete-btn').addEventListener('click', () => {
                            schedule[index].subtasks[subtaskIndex].completed = true;
                            localStorage.setItem('schedule', JSON.stringify(schedule));
                            renderTasks();
                        });
                    }

                    // Edit subtask
                    subtaskLi.querySelector('.edit-btn').addEventListener('click', () => {
                        subtaskEditForm.style.display = 'flex';
                        subtaskLi.style.display = 'none';
                    });

                    // Save edited subtask
                    subtaskEditForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        const newTask = subtaskEditForm.querySelector('[name="edit-subtask-task"]').value;
                        schedule[index].subtasks[subtaskIndex] = {
                            task: newTask,
                            completed: schedule[index].subtasks[subtaskIndex].completed
                        };
                        localStorage.setItem('schedule', JSON.stringify(schedule));
                        renderTasks();
                    });

                    // Cancel edit subtask
                    subtaskEditForm.querySelector('.cancel-edit-subtask').addEventListener('click', () => {
                        subtaskEditForm.style.display = 'none';
                        subtaskLi.style.display = 'flex';
                    });

                    // Delete subtask
                    subtaskLi.querySelector('.delete-btn').addEventListener('click', () => {
                        schedule[index].subtasks.splice(subtaskIndex, 1);
                        localStorage.setItem('schedule', JSON.stringify(schedule));
                        renderTasks();
                    });
                });

                completedTasksEl.appendChild(li);
                completedTasksEl.appendChild(editForm);
                completedTasksEl.appendChild(subtaskForm);
                completedTasksEl.appendChild(subtaskList);

                // Toggle subtasks
                li.querySelector('.toggle-subtasks').addEventListener('click', () => {
                    const isExpanded = subtaskList.classList.toggle('expanded');
                    li.querySelector('.toggle-subtasks').textContent = isExpanded ? '▼' : '◄';
                    li.querySelector('.toggle-subtasks').setAttribute('aria-expanded', isExpanded);
                });

                // Add subtask
                li.querySelector('.add-subtask-btn').addEventListener('click', () => {
                    subtaskForm.style.display = 'flex';
                    li.style.display = 'none';
                });

                // Save new subtask
                subtaskForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const description = subtaskForm.querySelector('[name="subtask-description"]').value;
                    if (!schedule[index].subtasks) schedule[index].subtasks = [];
                    schedule[index].subtasks.push({ task: description, completed: false });
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Cancel add subtask
                subtaskForm.querySelector('.cancel-subtask').addEventListener('click', () => {
                    subtaskForm.style.display = 'none';
                    li.style.display = 'flex';
                });

                // Move back to active
                li.querySelector('.back-btn').addEventListener('click', () => {
                    schedule[index].completed = false;
                    delete schedule[index].completedAt;
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Delete completed task
                li.querySelector('.delete-btn').addEventListener('click', () => {
                    schedule.splice(index, 1);
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Edit completed task
                li.querySelector('.edit-btn').addEventListener('click', () => {
                    editForm.style.display = 'flex';
                    li.style.display = 'none';
                });

                // Save edited completed task
                editForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const newStart = editForm.querySelector('[name="edit-start"]').value;
                    const newEnd = editForm.querySelector('[name="edit-end"]').value;
                    const newTask = editForm.querySelector('[name="edit-task"]').value;
                    const newSection = editForm.querySelector('[name="edit-section"]').value;

                    if (newStart >= newEnd) {
                        alert('End time must be after start time.');
                        return;
                    }

                    schedule[index] = { start: newStart, end: newEnd, task: newTask, section: newSection, completed: schedule[index].completed, completedAt: schedule[index].completedAt, subtasks: schedule[index].subtasks };
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                });

                // Cancel edit
                editForm.querySelector('.cancel-edit').addEventListener('click', () => {
                    editForm.style.display = 'none';
                    li.style.display = 'flex';
                });
            });

            // Show/hide clear completed button
            clearCompleted.style.display = completedTasks.length > 0 ? 'block' : 'none';
        }

        // Drag-and-drop handlers
        const dropZones = document.querySelectorAll('ul');
        dropZones.forEach(zone => {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                const dragging = document.querySelector('.dragging');
                if (dragging.classList.contains('subtask') && !zone.classList.contains('subtask-list')) {
                    // Allow subtasks to be dropped only in section lists for moving parent task
                    if (zone.dataset.section) {
                        zone.classList.add('drag-over');
                    }
                } else if (dragging.classList.contains('subtask') && zone.classList.contains('subtask-list') && zone.dataset.parentIndex === dragging.dataset.parentIndex) {
                    // Allow subtasks to be dropped in their own subtask-list for reordering
                    zone.classList.add('drag-over');
                } else if (dragging.classList.contains('task') && !zone.classList.contains('subtask-list')) {
                    // Allow tasks to be dropped in section lists
                    zone.classList.add('drag-over');
                }
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('drag-over');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                const data = e.dataTransfer.getData('text/plain').split(':');
                const index = parseInt(data[0], 10);
                const subtaskIndex = data[1] ? parseInt(data[1], 10) : null;
                const newSection = zone.dataset.section;
                const parentIndex = parseInt(zone.dataset.parentIndex, 10);

                if (subtaskIndex !== null && index >= 0 && index < schedule.length && subtaskIndex >= 0 && subtaskIndex < schedule[index].subtasks.length) {
                    // Subtask drag-and-drop
                    if (zone.classList.contains('subtask-list') && parentIndex === index) {
                        // Reorder within same parent task
                        const afterSubtaskElement = getSubtaskAfterElement(zone, e.clientY, index);
                        const parentTask = schedule[index];
                        const [movedSubtask] = parentTask.subtasks.splice(subtaskIndex, 1);
                        const newSubtaskIndex = afterSubtaskElement
                            ? parentTask.subtasks.findIndex(st => st.task === afterSubtaskElement.dataset.task)
                            : parentTask.subtasks.length;
                        parentTask.subtasks.splice(newSubtaskIndex === -1 ? parentTask.subtasks.length : newSubtaskIndex, 0, movedSubtask);
                    } else if (newSection) {
                        // Move parent task to new section
                        const afterElement = getDragAfterElement(zone, e.clientY);
                        const [movedTask] = schedule.splice(index, 1);
                        let insertIndex;
                        if (afterElement) {
                            insertIndex = schedule.findIndex(t => t.start === afterElement.dataset.start && t.end === afterElement.dataset.end && t.task === afterElement.dataset.task);
                            if (insertIndex === -1) insertIndex = schedule.length;
                        } else {
                            insertIndex = schedule.length;
                        }
                        if (newSection === 'completed') {
                            movedTask.completed = true;
                            movedTask.completedAt = Date.now();
                        } else {
                            movedTask.completed = false;
                            delete movedTask.completedAt;
                            movedTask.section = newSection;
                        }
                        schedule.splice(insertIndex, 0, movedTask);
                    }
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                } else if (index >= 0 && index < schedule.length && !subtaskIndex && !zone.classList.contains('subtask-list')) {
                    // Task drag-and-drop
                    const task = schedule[index];
                    const afterElement = getDragAfterElement(zone, e.clientY);
                    const [movedTask] = schedule.splice(index, 1);
                    let insertIndex;
                    if (afterElement) {
                        insertIndex = schedule.findIndex(t => t.start === afterElement.dataset.start && t.end === afterElement.dataset.end && t.task === afterElement.dataset.task);
                        if (insertIndex === -1) insertIndex = schedule.length;
                    } else {
                        insertIndex = schedule.length;
                    }
                    if (newSection === 'completed') {
                        movedTask.completed = true;
                        movedTask.completedAt = Date.now();
                    } else {
                        movedTask.completed = false;
                        delete movedTask.completedAt;
                        movedTask.section = newSection;
                    }
                    schedule.splice(insertIndex, 0, movedTask);
                    localStorage.setItem('schedule', JSON.stringify(schedule));
                    renderTasks();
                }
            });
        });

        // Helper function to determine the closest task for reordering
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('li.task:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Helper function to determine the closest subtask for reordering
        function getSubtaskAfterElement(container, y, parentIndex) {
            const draggableElements = [...container.querySelectorAll(`li.subtask:not(.dragging)[data-parent-index="${parentIndex}"]`)];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Clear completed tasks
        clearCompleted.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all completed tasks?')) {
                schedule = schedule.filter(task => !task.completed);
                localStorage.setItem('schedule', JSON.stringify(schedule));
                renderTasks();
            }
        });

        // Add task
        addTaskForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const start = document.getElementById('start-time').value;
            const end = document.getElementById('end-time').value;
            const taskName = document.getElementById('task-name').value;
            const section = document.getElementById('section').value;

            if (start >= end) {
                alert('End time must be after start time.');
                return;
            }

            schedule.push({ start, end, task: taskName, section, completed: false, subtasks: [] });
            localStorage.setItem('schedule', JSON.stringify(schedule));
            renderTasks();
            addTaskForm.reset();
        });

        // Update current task and timer
        function updateTimer() {
            const now = new Date();
            const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            let currentTask = null;

            schedule.forEach(task => {
                if (!task.completed && currentTime >= task.start && currentTime < task.end) {
                    currentTask = task;
                    task.element = document.querySelector(`li.task[data-start="${task.start}"][data-end="${task.end}"][data-task="${task.task}"]`);
                }
            });

            document.querySelectorAll('li.task').forEach(li => li.classList.remove('active'));

            if (currentTask) {
                currentTaskEl.textContent = `Current Task: ${currentTask.task}`;
                const endTime = new Date();
                const [endHours, endMinutes] = currentTask.end.split(':').map(Number);
                endTime.setHours(endHours, endMinutes, 0, 0);
                const timeLeft = endTime - now;
                if (timeLeft > 0) {
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000);
                    timerEl.textContent = `Time Left: ${minutes}m ${seconds}s`;
                    if (notificationsEnabled && minutes === 0 && seconds <= 10 && seconds > 0) {
                        if (Notification.permission === 'granted') {
                            new Notification(`Task "${currentTask.task}" ending soon!`);
                        }
                        alertSound.play().catch(() => console.log('Audio playback failed'));
                    }
                } else {
                    currentTaskEl.textContent = 'Current Task: None';
                    timerEl.textContent = 'Time Left: --';
                    if (notificationsEnabled && Notification.permission === 'granted') {
                        new Notification(`Task "${currentTask.task}" has ended!`);
                    }
                    if (notificationsEnabled) {
                        alertSound.play().catch(() => console.log('Audio playback failed'));
                    }
                }
                if (currentTask.element) {
                    currentTask.element.classList.add('active');
                }
            } else {
                currentTaskEl.textContent = 'Current Task: None';
                timerEl.textContent = 'Time Left: --';
            }
        }

        // Initial render and timer update
        renderTasks();
        updateTimer();
        setInterval(updateTimer, 1000);
    </script>
</body>
</html>

